#!/usr/local/bin/python

import argparse
import os
import sys
import subprocess
import json
from collections import OrderedDict

#####################################################################
# 
# CHORDS management script. Use to manage the CHORDS portal configuration,
# running/stopping the portal, and updating the portal software.
#
# The CHORDS configuration is kept in a YAML file (default chords.yml).
# This file contains standard configuration items, followed by user
# created non-standard options. The later are for developer use only.
#
# In configuration mode (-c), the existing configuration will be 
# read from the configuration file, the user will be prompted for changes,
# and the configuration file will be re-written. For each configuration item,
# the user may select the current value (hit enter), select the default
# value (enter a period), or change the value (enter a new value). The configuration
# may be initialized to complete default vaues by using the -d switch in conjunction
# with -c. 
#
# If the CHORDs configuration file does not exist, then it will be created. Thus,
# to create an initial default configuration, use:
#    ./chords_control -c -d
#
# A .env file is also created by the configuration mode. It contains
#  environment variable commands, with one for each configuration item. 
# This .env file is used by docker-compose. The non-standard options will 
# be included in .env, allowing developers to test additional environment variables,
# without having to edit the standardoptions specified in this script.
#
# The -r and -s switches are used to run/stop a portal.
#
# The -u switch updates the portal software by pulling the docker images.
#
# Use -t to see the current portal status.
#
# The devmode (-m) enables development mode, where the current directory
# is mounted as the CHORDS Rails source.
#
#####################################################################
"""
The definitions of standard configuration items. This are tri-tuples:
 [0]: The configuration item description. This will be printed as a prompt
      during configuration, and included in the configuration file as a description.
 [1]: The name of the environment variable to be set in the .env file.
 [2]: The default value.
"""
standardConfig = [
    [
        "The password for r/w and admin access to CHORDS, mysql and influxdb.\n"
        "Replace this with a strong password.",
        "CHORDS_ADMIN_PW",  
        "chords_ec_demo"
    ],
    [
        "The password for read-only access to influxdb.",
        "CHORDS_GUEST_PW",
        "guest"
    ],
    [
        "A secret key base for Rails. Generate a secure value (*add link with instructions*).",
        "SECRET_KEY_BASE",
        "aaaaaaaaaaa"
    ],
    [
        "The time series database retention duration, e.g. 168h or 52w. Use \"inf\" for permanent.\n"
        "This value can be changed on successive restarts of a portal. Note: making it shorter\n"
        "will trim the existing time series database.",
        "DB_RETENTION",
        "inf"
    ],
    [
        "The docker image tag of the desired CHORDS image.",
        "DOCKER_TAG",
        "latest"
    ],
    [
        "The RAILS environment. Unlikely to to be anything other than \"production\".",
        "RAILS_ENV",
        "production"
    ],
    [
        "The number of nginx workers.",
        "WORKERS",
        4
    ]
]

"""
Verbose flag
"""
verbose = False

#####################################################################
"""
"""
class ChordsConfig(OrderedDict):
    def __init__(self, options):
        OrderedDict.__init__(self)
        
        # Initialize the configuration item descriptions. These are 
        # used as comments in the output configuration file.
        self.initConfigItems()

        self.getPairs(options)
                
    def getPairs(self, options):
        
        items = dict()
        # Get the current configuration file
        if not os.path.isfile(options["file"]):
            f = open(options["file"], 'w')
            f.close()
            print options["file"], 'has been created'
        
        f = open(options["file"])
        lines = f.readlines()
        f.close()
        i = 1
        for l in lines:
            l = l.strip()
            if len(l):
                if l[0] != "#":
                    tokens = l.split(":")
                    if len(tokens) != 2:
                        print "Error at line", i, "<" + l + ">"
                        sys.exit(1)
                    items[tokens[0].strip()] = tokens[1].strip()
            i = i + 1

        config = OrderedDict()
        # Collect all of the standard items. Add them if they
        # weren't in the file
        for key in self.configItems.keys():
            if key in items.keys():
                config[key] = items[key]
                del items[key]
            else:
                config[key] = self.configItems[key]
        for key in items.keys():
            # Append any remaining items that aren't in the standard list
            config[key] = items[key]
        for key in config.keys():
            self[key] = config[key]
        
        
    """
    Create a collection of config items which must be in the final configuration.
    These items define the default values which will be used if they haven't already been
    set in a configuration.
    """
    def initConfigItems(self):
        self.configItems  = OrderedDict()
        
        for i in standardConfig:
            self.configItems[i[1]] = ConfigItem(description=i[0], default=i[2])

    """
    Create the YML version of the configuration. Line terminators will be included.
    The standard items are wrtten first, followed by the extras.
    """
    def toYML(self):
        yml = ''
        for key in self.keys():
            if key in self.configItems.keys():
                descripts = self.configItems[key]['description'].split('\n')
                for d in descripts:
                    yml =  yml + '# ' + d + '\n'
                yml = yml + key + ': ' + str(self[key]) + '\n'
        yml = yml +  '#' + '\n' + '# Non-standard options.' + '\n'
        for key in self.keys():
            if key not in self.configItems.keys():
                yml = yml + key + ': ' + str(self[key]) + '\n'
        return yml
    
    """
    Go through the configuration, asking the user if they want to 
    change the values. The response can be a return, to accept the
    value, a new value to replace the value, or a period to use the default value.
    The items found in configItems are done first, followed by all other
    items.
    """
    def queryValues(self, options):
        print 'Enter a return to keep the current value, a period to set to the default, or a new value.'

        for key in self.keys():
            if key in self.configItems.keys():
                self.queryValue(key=key, 
                                options = options,
                                description=self.configItems[key]['description'],
                                default=self.configItems[key]['default'])
        for key in self.keys():
            if key not in self.configItems.keys():
                self.queryValue(key=key, options = options)
    """
    Query the user for a replacement value.
    """
    def queryValue(self, key, options, description=None, default=None):
        print
        if description:
            print description
        print key,
        if default:
            print "(default: " + str(default) + ")" ,
        print '[' + self[key] + ']? ',
        if not options["default"]:
            l = sys.stdin.readline().strip()
        else:
            l = "."
            print ".",
        # An empty line means retain value
        if l != "":
            # A period means use the default, if it is avaiable
            if l == ".":
                if default:
                    self[key] = default
            # Other replace with the user entered value
            else:
                self[key] = l
    
    """
    Write the configuration to the file. The whole configuration is written,
    starting with the elements listed in the configItems. Configuration items
    are prefixed with the comments provided in the configItems.
    """
    def writeYMLFile(self, options):
        f = open(options["file"], "w")
        f.write(self.toYML())
        f.close()
        print 
        print "*** " + options["file"] + " has been written with the new configuration."

    """
    Write the configuration to the .env file, in environment
    notation.
    """
    def writeEnvFile(self):
        f = open(".env", 'w')
        for key in self.keys():
            f.write(key + "=" + str(self[key])+"\n")
        f.close()
        print "*** .env has been written with the new configuration."
        
    
#####################################################################
"""
"""
class ConfigItem(OrderedDict):
    def __init__(self, default, description):
        OrderedDict.__init__(self)
        self["default"] = default
        self["description"] = description
    
#####################################################################
"""
Manage the command line options.
The options are collated in a dictionary keyed on the option long name.
The option dictionary will have None for options that aren't present.
"""
class CommandArgs:
    def __init__(self):
        
        description=("""
        CHORDS configuration and operation management.
        
        In configuration mode, you are prompted for configuration options. These will be
        saved in the configuration file and in a corresponding .env file. Use the -d option
        to set the configuration to default values.
        """)
        
        epilog = ("""
        Only one of -c, -r, -s, or -u can be specified. -d must be accompanied by -c.
        To create an initial default configuration: ./chords_control -c -d
        """)
        
        parser = argparse.ArgumentParser(description=description, epilog=epilog)
        parser.add_argument("-f", "--file",    help="configuration file (default chords.yml)",              default="chords.yml", action="store")
        parser.add_argument("-c", "--config",  help="prompt for configuration and write config/.env files", default=False,        action="store_true")
        parser.add_argument("-d", "--default", help="set all configuration values to defaults",             default=False,        action="store_true")
        parser.add_argument("-r", "--run",     help="run",                                                  default=False,        action="store_true")
        parser.add_argument("-s", "--stop",    help="stop",                                                 default=False,        action="store_true")
        parser.add_argument("-u", "--update",  help="update",                                               default=False,        action="store_true")
        parser.add_argument("-t", "--status",  help="status",                                               default=False,        action="store_true")
        parser.add_argument("-m", "--devmode", help="run containers in source code development mode",       default=False,        action="store_true")
        parser.add_argument("-v", "--verbose", help="enable verbose",                                       default=False,        action="store_true")

        # Parse the command line. 
        args = parser.parse_args()
        self.options = vars(args)
        
        # Make sure that at most only one of these args was specified
        o = self.options
        if [o['config'], o['run'], o['stop'], o['update']].count(True) > 1:
            print epilog
            exit(1)
            
        if o['default'] and not o['config']:
            print epilog
            exit(1)
            
    def get_options(self):
        # return the dictionary of existing options.
        return self.options 

#####################################################################
"""
Manage docker activities. docker-compose.yml and docker-compose-dev.yml are 
expected in the working directory.
"""
class Docker:
    def __init__(self):
        self.docker_compose_cmd = '/usr/local/bin/docker-compose'
    
    """
    Return an array containing a dictionary for each currently running container.
    The dictionaries keys are a subset of the output columns from docker ps. They are:
        name:
        runningfor
        status
        createdat
        image
    """
    def ps(self):
        ps_cmd = ['docker',
              'ps', 
              '--format', 
              '\"name\":\"{{.Names}}\", \"runningfor\":\"{{.RunningFor}}\", \"status\":\"{{.Status}}\", \"createdat\":\"{{.CreatedAt}}\", \"image\":\"{{.Image}}\"']

        ps_result = os_cmd(ps_cmd, printlines=False).split('\n')

        containers = []
        for p in ps_result:
            p = p.strip()
            if p != '':
                p = '{' + p + '}'
                containers.append(json.loads(p))
        
        # Convert the json unicode to bytes
        return byteify(containers)
    
    """
    Bring the containers up with docker-compose.
    """
    def up(self, devmode=False):
        if devmode == False:
            up_cmd = [self.docker_compose_cmd,
              '-p', 'chords', 'up', '-d']
        else:
            up_cmd = [self.docker_compose_cmd,
              '-p', 'chords', 
              '-f', 'docker-compose.yml', '-f', 'docker-compose-dev.yml', 
              'up', '-d']
            
        print os_cmd(up_cmd)
    
    """
    Take the containers down with docker-compose.
    """
    def down(self):
        dn_cmd = [self.docker_compose_cmd,
              '-p', 'chords', 'down']
        print os_cmd(dn_cmd)

    """
    Pull docker images.
    """
    def pull(self):
        dn_cmd = [self.docker_compose_cmd,
              'pull']
        print os_cmd(dn_cmd)

#####################################################################
"""
Run a shell command. The command output is returned as a single string, with each
line delimited by a newline. 
"""
def os_cmd(cmd, printlines=True):
    if verbose:
        print ' '.join(str(x) for x in cmd)
    try:
        proc = subprocess.Popen(cmd,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        lines = ''
        while True:
          line = proc.stdout.readline()
          lines = lines + line
          if line != '':
            #the real code does filtering here
            if printlines:
                print line.rstrip()
          else:
            break
        return lines
    except Exception as e:
        print str(e) + ': ' + ' '.join(str(x) for x in cmd)


#####################################################################
"""
Convert unicode to a byte strings
"""
def byteify(input):
    if isinstance(input, dict):
        return {byteify(key): byteify(value)
                for key, value in input.iteritems()}
    elif isinstance(input, list):
        return [byteify(element) for element in input]
    elif isinstance(input, unicode):
        return input.encode('utf-8')
    else:
        return input
    
#####################################################################
#####################################################################

# Get the command line options
options = CommandArgs().get_options()
verbose = options['verbose']

if options["config"] == True:
    config = ChordsConfig(options=options)
    config.queryValues(options)
    config.writeYMLFile(options)
    config.writeEnvFile()

if options["run"] == True:
    Docker().up(options['devmode'])
    
if options["stop"] == True:
    Docker().down()

if options["status"] == True:
    for c in Docker().ps():
        print c['name'] + ': ' + str(c)

if options["update"] == True:
    Docker().pull()
