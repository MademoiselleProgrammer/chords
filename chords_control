#!/usr/local/bin/python

import argparse
import os
import sys
import subprocess
import json
from collections import OrderedDict

standardConfig = [
    [
        "The password for r/w and admin access to CHORDS, mysql and influxdb.\n"
        "Replace this with a strong password.",
        "CHORDS_ADMIN_PW",  
        "chords_ec_demo"
    ],
    [
        "The password for read-only access to influxdb.",
        "CHORDS_GUEST_PW",
        "guest"
    ],
    [
        "A secret key base for Rails. Generate a secure value (*add link with instructions*).",
        "SECRET_KEY_BASE",
        "aaaaaaaaaaa"
    ],
    [
        "The time series database retention duration, e.g. 168h or 52w. Use \"inf\" for permanent.\n"
        "This value can be changed on successive restarts of a portal. Note: making it shorter\n"
        "will trim the existing time series database.",
        "DB_RETENTION",
        "inf"
    ],
    [
        "The docker image tag of the desired CHORDS image.",
        "DOCKER_TAG",
        "latest"
    ],
    [
        "The RAILS environment. Unlikely to to be anything other than \"production\".",
        "RAILS_ENV",
        "production"
    ],
    [
        "The number of nginx workers.",
        "WORKERS",
        4
    ]
]


#####################################################################
"""
"""
class ChordsConfig(OrderedDict):
    def __init__(self, options):
        OrderedDict.__init__(self)
        
        # Initialize the configuration item descriptions. These are 
        # used as comments in the output configuration file.
        self.initConfigItems()

        self.getPairs(options)
                
    def getPairs(self, options):
        
        items = dict()
        # Get the current configuration file
        if not os.path.isfile(options["file"]):
            f = open(options["file"], 'w')
            f.close()
            print options["file"], 'has been created'
        
        f = open(options["file"])
        lines = f.readlines()
        f.close()
        i = 1
        for l in lines:
            l = l.strip()
            if len(l):
                if l[0] != "#":
                    tokens = l.split(":")
                    if len(tokens) != 2:
                        print "Error at line", i, "<" + l + ">"
                        sys.exit(1)
                    items[tokens[0].strip()] = tokens[1].strip()
            i = i + 1

        config = OrderedDict()
        # Collect all of the standard items. Add them if they
        # weren't in the file
        for key in self.configItems.keys():
            if key in items.keys():
                config[key] = items[key]
                del items[key]
            else:
                config[key] = self.configItems[key]
        for key in items.keys():
            # Append any remaining items that aren't in the standard list
            config[key] = items[key]
        for key in config.keys():
            self[key] = config[key]
        
        
    """
    Create a collection of config items which must be in the final configuration.
    These items define the default values which will be used if they haven't already been
    set in a configuration.
    """
    def initConfigItems(self):
        self.configItems  = OrderedDict()
        
        for i in standardConfig:
            self.configItems[i[1]] = ConfigItem(description=i[0], default=i[2])

    """
    Create the YML version of the configuration. Line terminators will be included.
    The standard items are wrtten first, followed by the extras.
    """
    def toYML(self):
        yml = ''
        for key in self.keys():
            if key in self.configItems.keys():
                descripts = self.configItems[key]['description'].split('\n')
                for d in descripts:
                    yml =  yml + '# ' + d + '\n'
                yml = yml + key + ': ' + str(self[key]) + '\n'
        yml = yml +  '#' + '\n' + '# Non-standard options.' + '\n'
        for key in self.keys():
            if key not in self.configItems.keys():
                yml = yml + key + ': ' + str(self[key]) + '\n'
        return yml
    
    """
    Go through the configuration, asking the user if they want to 
    change the values. The response can be a return, to accept the
    value, a new value to replace the value, or a period to use the default value.
    The items found in configItems are done first, followed by all other
    items.
    """
    def queryValues(self, options):
        print 'Enter a return to keep the current value, a period to set to the default, or a new value.'

        for key in self.keys():
            if key in self.configItems.keys():
                self.queryValue(key=key, 
                                options = options,
                                description=self.configItems[key]['description'],
                                default=self.configItems[key]['default'])
        for key in self.keys():
            if key not in self.configItems.keys():
                self.queryValue(key=key, options = options)
    """
    Query the user for a replacement value.
    """
    def queryValue(self, key, options, description=None, default=None):
        print
        if description:
            print description
        print key,
        if default:
            print "(default: " + str(default) + ")" ,
        print '[' + self[key] + ']? ',
        if not options["default"]:
            l = sys.stdin.readline().strip()
        else:
            l = "."
            print ".",
        # An empty line means retain value
        if l != "":
            # A period means use the default, if it is avaiable
            if l == ".":
                if default:
                    self[key] = default
            # Other replace with the user entered value
            else:
                self[key] = l
    
    """
    Write the configuration to the file. The whole configuration is written,
    starting with the elements listed in the configItems. Configuration items
    are prefixed with the comments provided in the configItems.
    """
    def writeYMLFile(self, options):
        f = open(options["file"], "w")
        f.write(self.toYML())
        f.close()
        print 
        print "*** " + options["file"] + " has been written with the new configuration."

    """
    Write the configuration to the .env file, in environment
    notation.
    """
    def writeEnvFile(self):
        f = open(".env", 'w')
        for key in self.keys():
            f.write(key + "=" + str(self[key])+"\n")
        f.close()
        print 
        print "*** .env has been written with the new configuration."
        
    
#####################################################################
"""
"""
class ConfigItem(OrderedDict):
    def __init__(self, default, description):
        OrderedDict.__init__(self)
        self["default"] = default
        self["description"] = description
    
#####################################################################
"""
Manage the command line options.
The options are collated in a dictionary keyed on the option long name.
The option dictionary will have None for options that aren't present.
"""
class CommandArgs:
    def __init__(self):
        
        description=("""
        CHORDS configuration and operation management.
        
        In configuration mode, you are prompted for configuration options. These will be
        saved in th configuration file. With -e, the CHORDS environment file (".env") will also
        be created from the configuration.
        """)
        
        epilog = ("""
        Only one of -c, -r, -s, or -u can be specified.
        """)
        
        parser = argparse.ArgumentParser(description=description, epilog=epilog)
        parser.add_argument("-f", "--file",        help="configuration file (default chords.yml)", default="chords.yml", action="store")
        parser.add_argument("-c", "--config",      help="configure",      default=False, action="store_true")
        parser.add_argument("-r", "--run",         help="run",            default=False, action="store_true")
        parser.add_argument("-s", "--stop",        help="stop",           default=False, action="store_true")
        parser.add_argument("-u", "--update",      help="update",         default=False, action="store_true")
        parser.add_argument("-d", "--default",     help="set all values to defaults", default=False, action="store_true")
        parser.add_argument("-e", "--env",         help="create/update .env", default=False, action="store_true")
        parser.add_argument("-v", "--verbose",     help="verbose output", default=False, action="store_true")

        # Parse the command line. 
        args = parser.parse_args()
        self.options = vars(args)
        
        # Make sure that at most only one of these args was specified
        o = self.options
        if [o['config'], o['run'], o['stop'], o['update']].count(True) > 1:
            parser.print_help()
            exit(1)
        
    def get_options(self):
        # return the dictionary of existing options.
        return self.options 

class Docker:
    def __init__(self):
        pass
    
    """
    Return an array containing a dictionary for each currently running container.
    The dictionaries keys are a subset of the output columns from docker ps. They are:
        name:
        runningfor
        status
        createdat
        image
    """
    def ps(self):
        ps_cmd = ['docker',
                  'ps', 
                  '--format', 
                  '\"name\":\"{{.Names}}\", \"runningfor\":\"{{.RunningFor}}\", \"status\":\"{{.Status}}\", \"createdat\":\"{{.CreatedAt}}\", \"image\":\"{{.Image}}\"']

        ps_result = subprocess.check_output(ps_cmd).split('\n')

        containers = []
        for p in ps_result:
            p = p.strip()
            if p != '':
                p = '{' + p + '}'
                containers.append(json.loads(p))
        
        # Convert the json unicode to bytes
        return byteify(containers)
        
"""
Convert unicode to a byte strings
"""
def byteify(input):
    if isinstance(input, dict):
        return {byteify(key): byteify(value)
                for key, value in input.iteritems()}
    elif isinstance(input, list):
        return [byteify(element) for element in input]
    elif isinstance(input, unicode):
        return input.encode('utf-8')
    else:
        return input
    
#####################################################################
#####################################################################

docker = Docker()
containers = docker.ps()
#for c in containers:
#    print c['name'] + ':' + str(c)

print

# Get the command line options
options = CommandArgs().get_options()

if options["config"] == True:
    config = ChordsConfig(options=options)
    config.queryValues(options)
    config.writeYMLFile(options)

if options["env"] == True:
    config.writeEnvFile()
